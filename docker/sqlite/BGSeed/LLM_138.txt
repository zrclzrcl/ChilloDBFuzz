CREATE TABLE employees (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE,
    phone_number VARCHAR(20),
    hire_date DATE NOT NULL,
    job_id INTEGER,
    salary DECIMAL(10, 2),
    commission_pct DECIMAL(4, 2),
    manager_id INTEGER,
    department_id INTEGER,
    FOREIGN KEY (job_id) REFERENCES jobs(id),
    FOREIGN KEY (department_id) REFERENCES departments(id),
    FOREIGN KEY (manager_id) REFERENCES employees(id)
);

CREATE TABLE departments (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name VARCHAR(100) NOT NULL UNIQUE,
    manager_id INTEGER,
    location_id INTEGER,
    FOREIGN KEY (manager_id) REFERENCES employees(id),
    FOREIGN KEY (location_id) REFERENCES locations(id)
);

CREATE TABLE jobs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    title VARCHAR(100) NOT NULL UNIQUE,
    min_salary DECIMAL(10, 2),
    max_salary DECIMAL(10, 2)
);

CREATE TABLE locations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    address VARCHAR(255),
    postal_code VARCHAR(20),
    city VARCHAR(50),
    state VARCHAR(50),
    country_id VARCHAR(2)
);

CREATE TABLE countries (
    id VARCHAR(2) PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    region_id INTEGER
);

INSERT INTO countries (id, name) VALUES ('US', 'United States of America');
INSERT INTO locations (address, postal_code, city, state, country_id) VALUES ('2011 Interiors Blvd', '99236', 'Southlake', 'Texas', 'US');
INSERT INTO departments (name, location_id) VALUES ('Software Development', 1);
INSERT INTO jobs (title, min_salary, max_salary) VALUES ('Software Engineer', 60000.00, 120000.00);
INSERT INTO employees (first_name, last_name, email, hire_date, job_id, salary, department_id) VALUES ('John', 'Doe', 'john.doe@example.com', '2023-01-15', 1, 80000.00, 1);
INSERT INTO employees (first_name, last_name, email, hire_date, job_id, salary, department_id, manager_id) VALUES ('Jane', 'Smith', 'jane.smith@example.com', '2023-02-20', 1, 90000.00, 1, 1);

-- Trigger to prevent salaries from being less than min_salary for a job
CREATE TRIGGER check_salary_min BEFORE INSERT ON employees
BEGIN
  SELECT RAISE(ABORT, 'Salary cannot be less than the minimum salary for this job')
  WHERE NEW.salary < (SELECT min_salary FROM jobs WHERE id = NEW.job_id);
END;

-- View to combine employee and department information
CREATE VIEW employee_details AS
SELECT
    e.id AS employee_id,
    e.first_name,
    e.last_name,
    e.email,
    e.salary,
    d.name AS department_name
FROM
    employees e
JOIN
    departments d ON e.department_id = d.id;

-- Generate some errors and edge cases
SELECT * FROM employees WHERE email LIKE '%@%';
SELECT AVG(salary) FROM employees;
SELECT department_id, COUNT(*) FROM employees GROUP BY department_id HAVING COUNT(*) > 1;
SELECT first_name, last_name FROM employees WHERE salary BETWEEN 70000 AND 100000 ORDER BY last_name DESC LIMIT 10 OFFSET 5;
SELECT sql FROM sqlite_master WHERE type='table' AND name='employees';
PRAGMA table_info(employees);
CREATE TABLE t1 (a INTEGER, b TEXT, c BLOB);
INSERT INTO t1 VALUES (1, 'test', randomblob(10));
SELECT typeof(a), typeof(b), typeof(c) FROM t1;
SELECT last_insert_rowid();
UPDATE employees SET salary = salary * 1.1 WHERE department_id = 1;
DELETE FROM employees WHERE first_name = 'John';
SELECT * FROM employee_details;
SELECT * FROM employees WHERE first_name GLOB '*oh*';
SELECT id FROM employees ORDER BY RANDOM() LIMIT 1;
ATTACH DATABASE 'test.db' AS aux;
CREATE TABLE aux.t2 (x INTEGER);
DETACH DATABASE aux;
PRAGMA integrity_check;
SELECT name FROM sqlite_master WHERE type='index';