DROP TABLE IF EXISTS employees;
CREATE TABLE employees (
    employee_id INTEGER PRIMARY KEY,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    email TEXT UNIQUE,
    phone_number TEXT,
    hire_date TEXT NOT NULL,
    job_id INTEGER,
    salary REAL,
    commission_pct REAL,
    manager_id INTEGER,
    department_id INTEGER
);

DROP TABLE IF EXISTS departments;
CREATE TABLE departments (
    department_id INTEGER PRIMARY KEY,
    department_name TEXT NOT NULL,
    location_id INTEGER
);

DROP TABLE IF EXISTS jobs;
CREATE TABLE jobs (
    job_id INTEGER PRIMARY KEY,
    job_title TEXT NOT NULL,
    min_salary REAL,
    max_salary REAL
);

-- Insert some sample data.  Using randomish data to try and trigger edge cases.
INSERT INTO employees (first_name, last_name, email, hire_date, job_id, salary, department_id) VALUES
('John', 'Doe', 'john.doe@example.com', '2022-01-01', 1, 60000.00, 10),
('Jane', 'Smith', 'jane.smith@example.com', '2022-02-15', 2, 75000.00, 20),
('Robert', 'Jones', 'robert.jones@example.com', '2022-03-01', 1, 62000.00, 10),
('Alice', 'Brown', 'alice.brown@example.com', '2022-04-10', 3, 90000.00, 30),
('Charlie', 'Davis', 'charlie.davis@example.com', '2022-05-01', 2, 78000.00, 20),
('Eve', 'Wilson', 'eve.wilson@example.com', '2022-06-15', 4, 110000.00, 40),
('Mallory', 'Garcia', 'mallory.garcia@example.com', '2022-07-01', 3, 95000.00, 30),
('Trent', 'Rodriguez', 'trent.rodriguez@example.com', '2022-08-10', 1, 65000.00, 10),
('Olivia', 'Williams', 'olivia.williams@example.com', '2022-09-01', 2, 80000.00, 20),
('Peggy', 'Moore', 'peggy.moore@example.com', '2022-10-15', 4, 115000.00, 40);

INSERT INTO departments (department_name, location_id) VALUES
('Sales', 100),
('Marketing', 200),
('Engineering', 300),
('Finance', 400);

INSERT INTO jobs (job_title, min_salary, max_salary) VALUES
('Sales Representative', 50000.00, 70000.00),
('Marketing Manager', 70000.00, 90000.00),
('Software Engineer', 80000.00, 120000.00),
('Financial Analyst', 100000.00, 130000.00);

-- Examples of potentially problematic queries to test SQLite specific features.

-- Test case-insensitive LIKE and GLOB operators, and also string concatenation.
SELECT first_name || ' ' || last_name AS full_name FROM employees WHERE first_name LIKE 'j%' COLLATE NOCASE;
SELECT first_name || ' ' || last_name AS full_name FROM employees WHERE first_name GLOB 'J*';

-- Test datetime functions.  Try to trigger overflow/underflow conditions.
SELECT strftime('%Y-%m-%d', hire_date, '+1 year') AS next_year FROM employees;
SELECT strftime('%J', '2024-01-01') - strftime('%J', hire_date) AS days_since_hired FROM employees;

-- Test coalesce function and numeric calculations with NULLs.
SELECT coalesce(commission_pct, 0.0) * salary AS bonus FROM employees;
SELECT salary * (1 + coalesce(commission_pct, 0.0)) AS total_compensation FROM employees;

-- Test aggregate functions and GROUP BY clause.
SELECT department_id, AVG(salary) AS avg_salary FROM employees GROUP BY department_id;
SELECT job_id, COUNT(*) AS employee_count FROM employees GROUP BY job_id HAVING employee_count > 2;

-- Test subqueries and JOINs.
SELECT e.first_name, e.last_name, d.department_name FROM employees e JOIN departments d ON e.department_id = d.department_id WHERE d.department_name = 'Sales';
SELECT first_name, last_name FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);

-- Test window functions (SQLite 3.25+).  These can expose interesting bugs.
SELECT first_name, last_name, salary, RANK() OVER (ORDER BY salary DESC) AS salary_rank FROM employees;
SELECT first_name, last_name, salary, ROW_NUMBER() OVER (ORDER BY salary DESC) AS row_num FROM employees;

-- Test WITHOUT ROWID tables.
DROP TABLE IF EXISTS no_rowid_table;
CREATE TABLE no_rowid_table (
    col1 INTEGER,
    col2 TEXT,
    PRIMARY KEY (col1, col2)
) WITHOUT ROWID;

INSERT INTO no_rowid_table (col1, col2) VALUES (1, 'abc'), (2, 'def');
SELECT * FROM no_rowid_table;

-- Test virtual tables (using FTS5 for full-text search - requires compilation option). If not supported, this will throw an error and stop processing but it is important to try.
DROP TABLE IF EXISTS documents;
CREATE VIRTUAL TABLE documents USING fts5(title, content);
INSERT INTO documents (title, content) VALUES ('SQLite Tutorial', 'This tutorial provides an introduction to SQLite.');
SELECT * FROM documents WHERE documents MATCH 'SQLite';

-- Test JSON functions (if SQLite version supports them)
SELECT json_extract('{"name": "John Doe", "age": 30}', '$.name');
SELECT json_group_array(salary) FROM employees;