CREATE TABLE employees (
    employee_id INTEGER PRIMARY KEY AUTOINCREMENT,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE,
    phone_number VARCHAR(20),
    hire_date DATE NOT NULL,
    job_id INTEGER,
    salary DECIMAL(10, 2),
    manager_id INTEGER,
    department_id INTEGER
);

CREATE TABLE departments (
    department_id INTEGER PRIMARY KEY AUTOINCREMENT,
    department_name VARCHAR(50) UNIQUE NOT NULL,
    location_id INTEGER
);

INSERT INTO employees (first_name, last_name, email, hire_date, job_id, salary, department_id) VALUES
('John', 'Doe', 'john.doe@example.com', '2022-01-15', 1, 60000.00, 10),
('Jane', 'Smith', 'jane.smith@example.com', '2023-03-20', 2, 75000.00, 20),
('Peter', 'Jones', 'peter.jones@example.com', '2022-08-01', 1, 62000.00, 10),
('Mary', 'Brown', 'mary.brown@example.com', '2023-05-10', 3, 80000.00, 20);

INSERT INTO departments (department_name) VALUES
('Sales'),
('Marketing');

-- Test case-insensitive LIKE operator
SELECT * FROM employees WHERE first_name LIKE 'jOhN%';

-- Test GLOB operator
SELECT * FROM employees WHERE email GLOB '*@example.com';

-- Test datetime functions
SELECT employee_id, hire_date, strftime('%Y', hire_date) AS hire_year FROM employees;

-- Test GROUP BY and aggregate functions
SELECT department_id, AVG(salary) AS avg_salary FROM employees GROUP BY department_id;

-- Test a common table expression (CTE)
WITH AvgSalaries AS (
    SELECT department_id, AVG(salary) AS avg_salary FROM employees GROUP BY department_id
)
SELECT e.first_name, e.last_name, d.department_name, a.avg_salary
FROM employees e
JOIN departments d ON e.department_id = d.department_id
JOIN AvgSalaries a ON e.department_id = a.department_id
WHERE e.salary > a.avg_salary;

-- Test the `instr` function, specific to SQLite
SELECT first_name, last_name FROM employees WHERE instr(email, 'example.com') > 0;

-- Test PRAGMA statement to query database size
PRAGMA database_size;

-- Test WITHOUT ROWID table
CREATE TABLE no_rowid_table (
    col1 INTEGER,
    col2 TEXT,
    PRIMARY KEY (col1, col2)
) WITHOUT ROWID;

INSERT INTO no_rowid_table VALUES (1, 'abc');
INSERT INTO no_rowid_table VALUES (2, 'def');

SELECT * FROM no_rowid_table;

-- Test `ON CONFLICT` clause in INSERT statement
CREATE TABLE conflict_table (
    id INTEGER PRIMARY KEY,
    value TEXT UNIQUE
);

INSERT INTO conflict_table (id, value) VALUES (1, 'abc');
INSERT INTO conflict_table (id, value) VALUES (2, 'def');
INSERT INTO conflict_table (id, value) VALUES (3, 'abc') ON CONFLICT REPLACE; -- Replace the existing row

SELECT * FROM conflict_table;