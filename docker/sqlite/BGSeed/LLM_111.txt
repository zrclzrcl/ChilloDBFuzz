BEGIN TRANSACTION;

-- Create a table with various data types and constraints
CREATE TABLE employees (
    employee_id INTEGER PRIMARY KEY AUTOINCREMENT,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE,
    phone_number VARCHAR(20),
    hire_date DATE DEFAULT (date('now')),
    job_id INTEGER,
    salary DECIMAL(10, 2) CHECK (salary > 0),
    commission_pct DECIMAL(4, 2),
    department_id INTEGER,
    FOREIGN KEY (department_id) REFERENCES departments(department_id)
);

-- Create a departments table for foreign key relationship
CREATE TABLE departments (
    department_id INTEGER PRIMARY KEY AUTOINCREMENT,
    department_name VARCHAR(50) NOT NULL,
    location_id INTEGER
);

-- Create a table to log changes. Demonstrates trigger functionality.
CREATE TABLE employee_audit (
    audit_id INTEGER PRIMARY KEY AUTOINCREMENT,
    employee_id INTEGER,
    old_salary DECIMAL(10, 2),
    new_salary DECIMAL(10, 2),
    updated_at DATETIME DEFAULT (datetime('now'))
);

-- Trigger to log salary changes in the employee_audit table.  A good target for mutation as the trigger logic can be complex.
CREATE TRIGGER salary_update
AFTER UPDATE OF salary ON employees
BEGIN
    INSERT INTO employee_audit (employee_id, old_salary, new_salary)
    VALUES (OLD.employee_id, OLD.salary, NEW.salary);
END;


-- Insert some sample data into employees
INSERT INTO employees (first_name, last_name, email, phone_number, job_id, salary, commission_pct, department_id)
VALUES ('John', 'Doe', 'john.doe@example.com', '123-456-7890', 1, 60000.00, 0.10, 10);
INSERT INTO employees (first_name, last_name, email, phone_number, job_id, salary, department_id)
VALUES ('Jane', 'Smith', 'jane.smith@example.com', '987-654-3210', 2, 75000.00, 20);
INSERT INTO employees (first_name, last_name, email, job_id, salary, department_id)
VALUES ('Alice', 'Johnson', 'alice.johnson@example.com', 3, 50000.00, 10);
INSERT INTO employees (first_name, last_name, email, job_id, salary, department_id)
VALUES ('Bob', 'Williams', 'bob.williams@example.com', 1, 65000.00, 20);
INSERT INTO employees (first_name, last_name, email, job_id, salary, department_id)
VALUES ('Charlie', 'Brown', 'charlie.brown@example.com', 2, 80000.00, 10);

-- Insert some sample data into departments
INSERT INTO departments (department_name, location_id) VALUES ('Sales', 1);
INSERT INTO departments (department_name, location_id) VALUES ('Marketing', 2);

-- Create a view to combine employee and department information. Views are good for fuzzing as they can hide underlying data changes.
CREATE VIEW employee_details AS
SELECT
    e.employee_id,
    e.first_name,
    e.last_name,
    e.email,
    e.phone_number,
    e.hire_date,
    e.salary,
    d.department_name
FROM
    employees e
JOIN
    departments d ON e.department_id = d.department_id;

-- Insert a NULL value to test NULL handling
INSERT INTO employees (first_name, last_name, email, salary, department_id) VALUES ('Null', 'Test', NULL, 50000, 10);

-- Update salary to trigger the salary_update trigger.
UPDATE employees SET salary = 61000.00 WHERE first_name = 'John';

--Vacuum the database to reduce fragmentation.
VACUUM;

COMMIT;