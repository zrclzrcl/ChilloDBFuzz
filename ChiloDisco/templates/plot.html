<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ChiloDisco · 数据大屏</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Orbitron:wght@500;600&family=Noto+Sans+SC:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/static/css/styles.css" />
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
</head>
<body>
  <canvas id="globalParticles"></canvas>
  <div id="app" class="layout">
    <aside class="sidenav">
      <div class="nav-brand">
        <span class="logo">⚡</span>
        <span class="title">ChiloDisco</span>
      </div>
      <nav class="nav-links">
        <a href="/">日志监控</a>
        <a class="active" href="/plot">数据大屏</a>
        <a href="/downloads">结果下载</a>
        <a href="#">系统设置</a>
      </nav>
    </aside>

    <div class="content">
      <header class="app-header">
        <div class="brand">
          <span class="subtitle">AFL++ · 数据可视化大屏</span>
        </div>
        <div class="controls" style="gap:12px">
          <label>刷新频率</label>
          <select id="intervalSel">
            <option value="100" selected>0.1s</option>
            <option value="200">0.2s</option>
            <option value="500">0.5s</option>
            <option value="1000">1s</option>
            <option value="2000">2s</option>
            <option value="5000">5s</option>
          </select>
          <span id="dataPath" style="color:var(--text-muted); font-size:13px"></span>
        </div>
      </header>

      <main id="mainGrid" class="grid" style="grid-template-columns: 1fr 1fr; grid-template-rows: 1.2fr 0.9fr 0.9fr 1fr; height: calc(100vh - 140px); min-height: 0; overflow: visible; padding: 20px;">
        <!-- 第1行：折线图，横跨两列 -->
        <section class="card" style="grid-column: 1 / span 2;">
          <header class="card-header">
            <div class="name">实时数据曲线</div>
            <div class="file" id="plot-meta"></div>
          </header>
          <div id="lineChart" style="width:100%; height:100%;"></div>
        </section>

        <!-- 第2行：两个仪表盘，各占一半 -->
        <section class="card">
          <header class="card-header" style="min-height: 40px; padding: 6px 12px;"><div class="name">Pending Total</div></header>
          <div id="gauge1" style="width:100%; height:100%;"></div>
        </section>
        <section class="card">
          <header class="card-header" style="min-height: 40px; padding: 6px 12px;"><div class="name">Pending Favs</div></header>
          <div id="gauge2" style="width:100%; height:100%;"></div>
        </section>

        <!-- 第3行：左边 Execs/sec 仪表盘；右边 最新指标 独立卡片 -->
        <section class="card">
          <header class="card-header" style="min-height: 40px; padding: 6px 12px;"><div class="name">Execs / Sec</div></header>
          <div id="gauge3" style="width:100%; height:100%;"></div>
        </section>
        <section class="card">
          <header class="card-header"><div class="name">实时指标</div></header>
          <div class="stats-compact" style="display:grid; grid-template-columns: repeat(2, 1fr); gap: 12px; height: calc(100% - 56px); padding: 16px;">
            <div class="stat-compact" id="s_cycles">
              <div class="stat-icon">🔄</div>
              <div class="stat-content">
                <div class="stat-label">Cycles</div>
                <div class="stat-value">—</div>
              </div>
            </div>
            <div class="stat-compact" id="s_cur_item">
              <div class="stat-icon">📌</div>
              <div class="stat-content">
                <div class="stat-label">Current</div>
                <div class="stat-value">—</div>
              </div>
            </div>
            <div class="stat-compact" id="s_saved_crashes">
              <div class="stat-icon">💥</div>
              <div class="stat-content">
                <div class="stat-label">Crashes</div>
                <div class="stat-value stat-danger">—</div>
              </div>
            </div>
            <div class="stat-compact" id="s_max_depth">
              <div class="stat-icon">📏</div>
              <div class="stat-content">
                <div class="stat-label">Depth</div>
                <div class="stat-value">—</div>
              </div>
            </div>
            <div class="stat-compact" id="s_total_execs" style="grid-column: 1 / -1;">
              <div class="stat-icon">🎯</div>
              <div class="stat-content">
                <div class="stat-label">Total Execs</div>
                <div class="stat-value">—</div>
              </div>
            </div>
          </div>
        </section>

        <!-- 第4行：.cur_input 展示大卡片，横跨两列 -->
        <section class="card" id="curCard" style="grid-column: 1 / span 2; transition: box-shadow .6s ease, border-color .6s ease;">
          <header class="card-header">
            <div class="name">当前输入样本</div>
            <div class="file" id="curMeta">（等待数据…）</div>
            <div class="meta">
              <span class="mtime" id="curTimer" title="当前内容持续时间">—</span>
            </div>
          </header>
          <div id="curContent" style="height: calc(100% - 56px); padding: 16px; overflow-x: hidden; overflow-y: auto; white-space: pre-wrap; word-break: break-word; overflow-wrap: anywhere; hyphens: auto; line-height: 1.5; font-size: 13px; column-gap: 24px; column-fill: auto; -webkit-column-fill: auto; column-rule: 1px solid var(--border-light); background: var(--bg-secondary);">
            （空）
          </div>
        </section>
      </main>

      <footer class="app-footer">
        <div class="legend">
          <span>数据说明：</span>
          <span>折线图：map_size, edges_found, corpus_count | 仪表盘：pending_total, pending_favs, execs_per_sec</span>
        </div>
        <div class="copyright">© 2025 ChiloDisco</div>
      </footer>
    </div>
  </div>

  <script>
    // 霓虹赛博朋克 ECharts 主题
    echarts.registerTheme('chiloNeon', {
      color: ['#00f0ff','#8b5cf6','#ff006e','#00ff9f','#ffed4e'],
      backgroundColor: 'transparent',
      textStyle: { fontFamily: 'JetBrains Mono, Noto Sans SC, monospace', color: '#e0e7ff' },
      grid: { containLabel: true },
      tooltip: { 
        backgroundColor: 'rgba(19,24,36,0.95)', 
        borderColor: 'rgba(0,240,255,0.5)',
        borderWidth: 2,
        textStyle:{ color: '#e0e7ff' },
        extraCssText: 'box-shadow: 0 0 20px rgba(0,240,255,0.4); backdrop-filter: blur(10px);'
      },
      categoryAxis: {
        axisLine: { lineStyle: { color: 'rgba(0,240,255,0.3)' }},
        axisLabel: { color: '#6b7280' },
        splitLine: { show: false }
      },
      valueAxis: {
        axisLine: { lineStyle: { color: 'rgba(0,240,255,0.3)' }},
        axisLabel: { color: '#6b7280' },
        splitLine: { lineStyle: { color: 'rgba(139,92,246,0.15)' }}
      },
      legend: { textStyle: { color: '#e0e7ff' } }
    });

    const intervalSel = document.getElementById('intervalSel');
    const dataPathEl = document.getElementById('dataPath');
    const metaEl = document.getElementById('plot-meta');
    const mainGrid = document.getElementById('mainGrid');

    let timer = null;
    let interval = parseInt(intervalSel.value, 10) || 100;

    // 使用霓虹赛博朋克主题初始化
    const lineChart = echarts.init(document.getElementById('lineChart'), 'chiloNeon');
    const gauge1 = echarts.init(document.getElementById('gauge1'), 'chiloNeon');
    const gauge2 = echarts.init(document.getElementById('gauge2'), 'chiloNeon');
    const gauge3 = echarts.init(document.getElementById('gauge3'), 'chiloNeon');

    // 横竖屏自适应布局
    const mqLandscape = window.matchMedia('(orientation: landscape)');

    // 工具：找到某个子元素所在的 section（卡片）
    function cardOf(childId){
      const el = document.getElementById(childId);
      return el ? el.closest('section') : null;
    }
    const lineCard  = cardOf('lineChart');
    const g1Card    = cardOf('gauge1');
    const g2Card    = cardOf('gauge2');
    const g3Card    = cardOf('gauge3');
    const curCardEl = document.getElementById('curCard');
    const statsCard = (function(){
      const s = document.getElementById('s_cycles');
      return s ? s.closest('section') : null;
    })();

    function applyLayout(){
      if (!mainGrid) return;
      const w = window.innerWidth || document.documentElement.clientWidth || 0;
      const h = window.innerHeight || document.documentElement.clientHeight || 0;
      const aspect = h > 0 ? (w / h) : 1.6;
      const headerFooter = 140; // 与模板一致的头尾高度估算
      mainGrid.style.height = `calc(100vh - ${headerFooter}px)`;

      if (mqLandscape.matches){
        // 横屏：第1行更高并放置"折线图 + 最新指标"；第2行三仪表盘更紧凑；第3行 .cur_input 占满
        mainGrid.style.gridTemplateColumns = '1fr 1fr 1fr';
        if (aspect >= 2.0){
          // 超宽横屏：显著抬高第1行，适当压缩仪表盘行
          mainGrid.style.gridTemplateRows = '2.6fr 1.3fr 1.9fr';
        } else if (aspect >= 1.6){
          // 标准横屏
          mainGrid.style.gridTemplateRows = '2.4fr 1.3fr 1.7fr';
        } else {
          // 过渡横屏
          mainGrid.style.gridTemplateRows = '2.2fr 1.2fr 1.6fr';
        }
        // 第1行：折线图占两列；最新指标占一列
        if (lineCard){ lineCard.style.gridColumn = '1 / span 2'; lineCard.style.gridRow = '1 / span 1'; }
        if (statsCard){ statsCard.style.gridColumn = '3 / span 1'; statsCard.style.gridRow = '1 / span 1'; }
        // 第2行：三个仪表盘分列（更小）
        if (g1Card){ g1Card.style.gridColumn = '1 / span 1'; g1Card.style.gridRow = '2 / span 1'; }
        if (g2Card){ g2Card.style.gridColumn = '2 / span 1'; g2Card.style.gridRow = '2 / span 1'; }
        if (g3Card){ g3Card.style.gridColumn = '3 / span 1'; g3Card.style.gridRow = '2 / span 1'; }
        // 第3行：.cur_input 跨三列
        if (curCardEl){ curCardEl.style.gridColumn = '1 / span 3'; curCardEl.style.gridRow = '3 / span 1'; }
      } else {
        // 竖屏：保留原有 2 列 × 4 行布局
        mainGrid.style.gridTemplateColumns = '1fr 1fr';
        mainGrid.style.gridTemplateRows    = '1.2fr 0.9fr 0.9fr 1fr';
        // 第1行：折线图跨两列
        if (lineCard){ lineCard.style.gridColumn = '1 / span 2'; lineCard.style.gridRow = '1 / span 1'; }
        // 第2行：两个仪表盘各占一半
        if (g1Card){ g1Card.style.gridColumn = '1 / span 1'; g1Card.style.gridRow = '2 / span 1'; }
        if (g2Card){ g2Card.style.gridColumn = '2 / span 1'; g2Card.style.gridRow = '2 / span 1'; }
        // 第3行：左 Execs/sec；右 最新指标
        if (g3Card){ g3Card.style.gridColumn = '1 / span 1'; g3Card.style.gridRow = '3 / span 1'; }
        if (statsCard){ statsCard.style.gridColumn = '2 / span 1'; statsCard.style.gridRow = '3 / span 1'; }
        // 第4行：.cur_input 跨两列
        if (curCardEl){ curCardEl.style.gridColumn = '1 / span 2'; curCardEl.style.gridRow = '4 / span 1'; }
      }
      // 重绘图表以适配
      lineChart.resize(); gauge1.resize(); gauge2.resize(); gauge3.resize();
    }
    mqLandscape.addEventListener ? mqLandscape.addEventListener('change', applyLayout) : mqLandscape.addListener(applyLayout);

    // 保持用户图例选择状态，避免刷新后被重置；并在点击后短暂停止轮询，防止刷新抢占
    // 使用 localStorage 持久化图例选择
    let legendSelected = null;
    try {
      const saved = localStorage.getItem('chiloPlotLegendSelected');
      if (saved) legendSelected = JSON.parse(saved);
    } catch(_) {}
    
    let pauseUntil = 0;
    lineChart.on('legendselectchanged', (e) => {
      legendSelected = Object.assign({}, e.selected);
      try {
        localStorage.setItem('chiloPlotLegendSelected', JSON.stringify(legendSelected));
      } catch(_) {}
      pauseUntil = Date.now() + 1000; // 1000ms 交互保护时间，增加到1秒
    });

    // 半圆仪表盘配置，更具美感
    function gaugeOption(name, val, maxVal, colorStops, unit, scale){
      const v = Number.isFinite(val) ? val : 0;
      const m = Math.max(1, maxVal || 100);
      const sc = Number.isFinite(scale) ? scale : 1.0;
      const colors = colorStops || [[0.3, '#00f0ff'], [0.7, '#8b5cf6'], [1, '#ff006e']];
      const axisW = Math.round(14 * sc);
      const ptrW  = Math.max(3, Math.round(4 * sc));
      const fz    = Math.round(28 * sc);
      const titleFz = Math.round(13 * sc);
      return {
        animationDurationUpdate: 300,
        series: [{
          type: 'gauge',
          startAngle: 200,
          endAngle: -20,
          center: ['50%', sc > 1 ? '66%' : '60%'],
          radius: sc > 1 ? '92%' : '88%',
          min: 0,
          max: m,
          splitNumber: 5,
          pointer: { show: true, length: '62%', width: ptrW, itemStyle: { color: '#00f0ff' } },
          progress: { show: true, overlap: false, roundCap: true, clip: false, itemStyle: { color: '#00f0ff' } },
          axisLine: { lineStyle: { width: axisW, color: colors }},
          axisTick: { show: false },
          splitLine: { show: false },
          axisLabel: { show: false },
          title: { show: true, color: '#00f0ff', fontSize: titleFz, offsetCenter: [0,'70%'] },
          detail: {
            valueAnimation: true,
            fontSize: fz,
            color: '#00f0ff',
            offsetCenter: [0, sc > 1 ? '30%' : '35%'],
            formatter: (x) => unit ? `${x}${unit}` : `${x}`
          },
          data: [{ value: v, name }]
        }]
      };
    }

    function hueForAge(ageSec){
      if (ageSec <= 2) return 140;
      if (ageSec <= 5) return 105;
      if (ageSec <= 10) return 80;
      if (ageSec <= 20) return 60;
      if (ageSec <= 40) return 40;
      if (ageSec <= 60) return 25;
      if (ageSec <= 90) return 12;
      return 0;
    }
    // 发光强度：时间越久越亮（与日志页相反）
    function growGlow(ageSec){
      if (ageSec <= 2) return { blur: 2, alpha: 0.15 };
      if (ageSec <= 5) return { blur: 4, alpha: 0.25 };
      if (ageSec <= 10) return { blur: 6, alpha: 0.35 };
      if (ageSec <= 20) return { blur: 8, alpha: 0.45 };
      if (ageSec <= 40) return { blur: 10, alpha: 0.55 };
      if (ageSec <= 60) return { blur: 12, alpha: 0.65 };
      if (ageSec <= 90) return { blur: 14, alpha: 0.75 };
      return { blur: 18, alpha: 0.9 };
    }

    function fmtDuration(sec){
      const s = Math.max(0, Math.floor(sec||0));
      const h = Math.floor(s/3600), m = Math.floor((s%3600)/60), ss = s%60;
      const pad = (x)=> (x<10?('0'+x):(''+x));
      return h>0 ? `${pad(h)}:${pad(m)}:${pad(ss)}` : `${pad(m)}:${pad(ss)}`;
    }

    function renderAll(data){
      const meta = data.meta || {}; const s = data.series || {};
      const t = s.t || [];
      const map_size = s.map_size || [];
      const edges_found = s.edges_found || [];
      const corpus_count = s.corpus_count || [];

      dataPathEl.textContent = meta.path ? ('文件：' + meta.path) : '未找到 plot_data';
      metaEl.textContent = meta.exists ? (new Date(meta.mtime).toLocaleString() + ' · ' + (meta.size||0) + 'B') : '等待数据…';

      // 更美观的折线：面积渐变 + 光晕 + 平滑动画；保留用户图例选择
      const opt = {
        backgroundColor: 'transparent',
        grid: { left: 60, right: 60, top: 50, bottom: 80 },
        animation: true,
        animationDuration: 600,
        animationEasing: 'quadraticOut',
        axisPointer: { link: [{ xAxisIndex: 'all' }], label: { backgroundColor: 'rgba(20,26,36,0.9)' } },
        tooltip: { trigger: 'axis', axisPointer: { type: 'line' } },
        legend: { 
          data: ['map_size(%)','edges_found','corpus_count'], 
          selected: legendSelected || undefined, 
          top: null, 
          bottom: 15, 
          left: 'center', 
          itemWidth: 40, 
          itemHeight: 24, 
          itemGap: 30, 
          selectedMode: 'multiple', 
          textStyle: { fontSize: 16, color: '#2d2d2d', fontWeight: 500 },
          padding: [10, 20]
        },
        xAxis: {
          type: 'value',
          min: 'dataMin',
          max: 'dataMax',
          boundaryGap: false,
          axisLabel: { color: '#6b6b6b' },
          splitLine: { show: false }
        },
        yAxis: [
          {
            type: 'value', name: '%', position: 'left', scale: true,
            min: function(v){
              const min = Number.isFinite(v.min) ? v.min : 0;
              const max = Number.isFinite(v.max) ? v.max : (min+1);
              if (min === max) return Math.max(0, min - 1);
              const pad = Math.max(0.5, (max - min) * 0.1); // 至少 0.5 个百分点留白
              return Math.max(0, min - pad);
            },
            max: function(v){
              const min = Number.isFinite(v.min) ? v.min : 0;
              const max = Number.isFinite(v.max) ? v.max : (min+1);
              if (min === max) return max + 1;
              const pad = Math.max(0.5, (max - min) * 0.1);
              return max + pad;
            },
            axisLabel: { formatter: '{value}%' }
          },
          {
            type: 'value', position: 'right', scale: true,
            min: function(v){
              const min = Number.isFinite(v.min) ? v.min : 0;
              const max = Number.isFinite(v.max) ? v.max : (min+1);
              if (min === max) return Math.max(0, min - 1);
              const pad = Math.max(1, (max - min) * 0.1); // 至少 1 的留白
              return Math.max(0, min - pad);
            },
            max: function(v){
              const min = Number.isFinite(v.min) ? v.min : 0;
              const max = Number.isFinite(v.max) ? v.max : (min+2);
              if (min === max) return max + 1;
              const pad = Math.max(1, (max - min) * 0.1);
              return max + pad;
            }
          },
          {
            type: 'value', position: 'right', scale: true, offset: 52,
            min: function(v){
              const min = Number.isFinite(v.min) ? v.min : 0;
              const max = Number.isFinite(v.max) ? v.max : (min+1);
              if (min === max) return Math.max(0, min - 1);
              const pad = Math.max(1, (max - min) * 0.1);
              return Math.max(0, min - pad);
            },
            max: function(v){
              const min = Number.isFinite(v.min) ? v.min : 0;
              const max = Number.isFinite(v.max) ? v.max : (min+2);
              if (min === max) return max + 1;
              const pad = Math.max(1, (max - min) * 0.1);
              return max + pad;
            }
          }
        ],
        series: [
          {
            name: 'map_size(%)', type: 'line', yAxisIndex: 0, smooth: true, showSymbol: false, data: t.map((ti,i)=>[ti, map_size[i]]),
            lineStyle:{ color:'#00f0ff', width: 3 },
            areaStyle:{
              opacity: 0.25,
              color: new echarts.graphic.LinearGradient(0,0,0,1,[{ offset:0, color:'rgba(0,240,255,0.4)'},{ offset:1, color:'rgba(0,240,255,0.05)'}])
            },
            emphasis: { focus: 'series' }
          },
          {
            name: 'edges_found', type: 'line', yAxisIndex: 1, smooth: true, showSymbol: false, data: t.map((ti,i)=>[ti, edges_found[i]]),
            lineStyle:{ color:'#8b5cf6', width: 3 },
            areaStyle:{ opacity: 0.25, color: new echarts.graphic.LinearGradient(0,0,0,1,[{offset:0,color:'rgba(139,92,246,0.4)'},{offset:1,color:'rgba(139,92,246,0.05)'}]) }
          },
          {
            name: 'corpus_count', type: 'line', yAxisIndex: 2, smooth: true, showSymbol: false, data: t.map((ti,i)=>[ti, corpus_count[i]]),
            lineStyle:{ color:'#ff006e', width: 3 },
            areaStyle:{ opacity: 0.25, color: new echarts.graphic.LinearGradient(0,0,0,1,[{offset:0,color:'rgba(255,0,110,0.4)'},{offset:1,color:'rgba(255,0,110,0.05)'}]) }
          }
        ]
      };
      if (legendSelected) {
        opt.legend.selected = legendSelected;
      }
      lineChart.setOption(opt, { notMerge: false, lazyUpdate: true });
      // 回读一次，确保获取用户最新选择状态（包括外部交互）
      try {
        const optNow = lineChart.getOption();
        if (optNow && optNow.legend && optNow.legend.length && optNow.legend[0].selected) {
          legendSelected = Object.assign({}, optNow.legend[0].selected);
        }
      } catch(_) {}

      const lastIdx = t.length ? t.length - 1 : -1;
      const latest = (k) => (s[k] && lastIdx>=0 ? s[k][lastIdx] : 0);

      // 仪表：根据当前值动态设置上限，使指针有富余空间；横屏按卡片高度动态缩放
      function gaugeScaleFor(card){
        try{
          const h = card ? card.clientHeight : 0;
          if (!h || !Number.isFinite(h)) return (mqLandscape.matches ? 1.15 : 0.95);
          if (mqLandscape.matches){
            // 横屏：略放大，但控制上限，避免过大遮挡
            return Math.max(1.05, Math.min(1.5, h / 340));
          } else {
            // 竖屏：整体稍微缩小一点点，留出更多空间
            return Math.max(0.85, Math.min(1.4, h / 360));
          }
        }catch(_){ return (mqLandscape.matches ? 1.15 : 0.95); }
      }
      const sc1 = gaugeScaleFor(g1Card);
      const sc2 = gaugeScaleFor(g2Card);
      const sc3 = gaugeScaleFor(g3Card);
      gauge1.setOption(gaugeOption('pending_total', latest('pending_total'), Math.max(10, latest('pending_total')*1.6), undefined, '', sc1));
      gauge2.setOption(gaugeOption('pending_favs', latest('pending_favs'), Math.max(10, latest('pending_favs')*1.6), undefined, '', sc2));
      gauge3.setOption(gaugeOption('execs_per_sec', latest('execs_per_sec'), Math.max(50, latest('execs_per_sec')*1.6), [[0.3,'#00ff9f'],[0.7,'#00f0ff'],[1,'#8b5cf6']], '', sc3));

      const setStat = (id, val) => { const el = document.querySelector('#'+id+' .stat-value'); if (el) el.textContent = (val ?? '—'); };
      setStat('s_cycles', latest('cycles_done'));
      setStat('s_cur_item', latest('cur_item'));
      setStat('s_saved_crashes', latest('saved_crashes'));
      setStat('s_max_depth', latest('max_depth'));
      setStat('s_total_execs', latest('total_execs'));

      // 渲染 .cur_input
      const cur = (data && data.cur_input) ? data.cur_input : null;
      const card = document.getElementById('curCard');
      const metaBox = document.getElementById('curMeta');
      const cont = document.getElementById('curContent');
      const timerBox = document.getElementById('curTimer');
      if (cur && card && cont && metaBox && timerBox){
        const m = cur.meta || {};
        const txt = (cur.content || '').replace(/^\uFEFF/, '');
        metaBox.textContent = m.exists ? `${m.path} · ${m.size||0}B · ${new Date(m.mtime||Date.now()).toLocaleString()}` : '未找到 .cur_input';
        timerBox.textContent = m.exists ? ('已运行 ' + fmtDuration(cur.since_sec||0)) : '—';

        // 内容展示：根据长度与方向自动切换列数（无横向滚动，不截断）
        const lines = txt.split(/\r?\n/);
        const isLandscape = mqLandscape.matches;
        let cols = (lines.length >= 120 || txt.length > 8000) ? 3 : ((lines.length >= 30 || txt.length > 1500) ? 2 : 1);
        // 要求：竖屏也应显示双栏，因此在竖屏下至少 2 栏；横屏至少 2 栏
        cols = Math.max(cols, 2);
        cont.style.columnCount = cols;
        cont.innerText = txt || '（空）';

        // 边框与发光：时间越久越红、越亮（日式简约版 - 降低效果）
        const age = Math.max(0, cur.since_sec||0);
        const h = hueForAge(age);
        const glow = growGlow(age);
        const border = `hsl(${h}, 40%, 65%)`;
        const outer = `0 0 ${Math.round(glow.blur*0.5)}px hsla(${h}, 40%, 55%, ${glow.alpha*0.3})`;
        card.style.borderColor = border;
        card.style.boxShadow = outer;
      }
    }

    async function fetchPlot(){
      try{
        if (Date.now() < pauseUntil) return; // 交互保护：暂停轮询，避免覆盖图例点击
        const r = await fetch('/api/plot?t=' + Date.now(), { cache: 'no-store' });
        const data = await r.json();
        renderAll(data);
      }catch(e){ console.error(e); }
    }

    function start(){ stop(); timer = setInterval(fetchPlot, interval); }
    function stop(){ if (timer) { clearInterval(timer); timer=null; } }

    intervalSel.addEventListener('change', () => { interval = parseInt(intervalSel.value,10)||100; start(); });
    window.addEventListener('resize', () => { applyLayout(); });

    applyLayout();
    fetchPlot();
    start();
    
    // 霓虹粒子特效 - 高密度可见版
    (function() {
      const canvas = document.getElementById('globalParticles');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      
      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resize();
      
      const particles = [];
      const N = Math.max(80, Math.floor((canvas.width * canvas.height) / 8000));
      
      const colors = [
        { r: 0, g: 240, b: 255 },    // 霓虹青
        { r: 139, g: 92, b: 246 },   // 霓虹紫
        { r: 255, g: 0, b: 110 },    // 霓虹粉
        { r: 0, g: 255, b: 159 }     // 霓虹绿
      ];
      
      for (let i = 0; i < N; i++) {
        const color = colors[Math.floor(Math.random() * colors.length)];
        particles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          r: Math.random() * 2 + 1,
          vx: (Math.random() - 0.5) * 0.5,
          vy: (Math.random() - 0.5) * 0.5,
          color: color,
          alpha: Math.random() * 0.6 + 0.4,
          phase: Math.random() * Math.PI * 2,
          speed: Math.random() * 0.03 + 0.01
        });
      }
      
      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        for (const p of particles) {
          p.x += p.vx;
          p.y += p.vy;
          p.phase += p.speed;
          
          if (p.x < -10) p.x = canvas.width + 10;
          if (p.x > canvas.width + 10) p.x = -10;
          if (p.y < -10) p.y = canvas.height + 10;
          if (p.y > canvas.height + 10) p.y = -10;
          
          const glow = 0.6 + 0.4 * Math.sin(p.phase);
          const glowRadius = p.r * 4 * glow;
          
          // 外层发光
          const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, glowRadius);
          grad.addColorStop(0, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${p.alpha * glow})`);
          grad.addColorStop(0.4, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${p.alpha * glow * 0.5})`);
          grad.addColorStop(1, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, 0)`);
          
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(p.x, p.y, glowRadius, 0, Math.PI * 2);
          ctx.fill();
          
          // 核心亮点
          ctx.fillStyle = `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${p.alpha * glow})`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
          ctx.fill();
        }
        
        requestAnimationFrame(animate);
      }
      
      animate();
      window.addEventListener('resize', () => {
        resize();
      });
      
      if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    })();
  </script>
</body>
</html>
